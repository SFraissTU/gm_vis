#version 450

#define FRAG_LIST_MAX_LEN 128

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct FragmentData {
	int gIndex;
	int flags;
	int next;
	int padding1;
	double z;
	double padding2;
	//ivec4 g_f_n;
	vec4 position;
};

layout(std430, binding=0) buffer FragmentList {
	FragmentData[] fragmentList;
} flb;

struct Gaussian {
	vec4 mu_alpha;
	mat4 invsigma;
};

struct GaussianRay {
	float a;
	float b;
	float c2;
	float padding;
	vec4 direction;
};

layout(std430, binding=1) buffer GaussianMixture {
	Gaussian gaussians[];
} mixture;

struct LinkedListElement {
	double z;
	int next;
};

//Ordered Linked List
struct CandidateList {
	LinkedListElement candidates[FRAG_LIST_MAX_LEN];
	int candidates_len;
	int candidates_next_index;
};

CandidateList createCandidateList() {
	CandidateList list;
	list.candidates_len = 0;
	list.candidates_next_index = 0;
	return list;
};

void insert(inout CandidateList list, double t, int initialinspectionindex, int initialpreviousindex) {
	int inspectionindex = initialinspectionindex;
	int previousindex = initialpreviousindex;
	while (inspectionindex < list.candidates_len && inspectionindex != -1) {
		LinkedListElement candidate = list.candidates[inspectionindex];
		if (candidate.z > t) {
			LinkedListElement newC;
			newC.z = t;
			newC.next = inspectionindex;
			list.candidates[list.candidates_len] = newC;
			if (previousindex == -1) {
				list.candidates_next_index = list.candidates_len;
			} else {
				list.candidates[previousindex].next = list.candidates_len;
			}
			list.candidates_len++;
			break;
		}
		previousindex = inspectionindex;
		inspectionindex = candidate.next;
	}
	if (inspectionindex == -1 || inspectionindex == list.candidates_len) {
		//insert at beginning or end
		LinkedListElement newC;
		newC.z = t;
		newC.next = -1;
		list.candidates[list.candidates_len] = newC;
		if (previousindex != -1) {
			list.candidates[previousindex].next = list.candidates_len;
		}
		list.candidates_len++;
	}
};

void insert(inout CandidateList list, double t) {
	int inspectionindex = list.candidates_next_index;
	int previousindex = -1;
	insert(list, t, inspectionindex, previousindex);
}

void insert(inout CandidateList list, double t1, double t2) {
	//Insert t1
	insert(list, t1);
	//Insert t2
	insert(list, t2, list.candidates[list.candidates_len-1].next, list.candidates_len-1);
};


bool hasNext(CandidateList list) {
	return list.candidates_next_index < list.candidates_len;
};

double getNextZ(CandidateList list) {
	return list.candidates[list.candidates_next_index].z;
}

double popZ(inout CandidateList list) {
	double z = list.candidates[list.candidates_next_index].z;
	list.candidates_next_index = list.candidates[list.candidates_next_index].next;
	if (list.candidates_next_index == -1) {
		list.candidates_next_index = list.candidates_len;
	}
	return z;
}

uniform uint listSize;
uniform uint width;
uniform uint height;
uniform float isolevel;
uniform float fov;
uniform sampler1D gaussTex;
uniform mat4 invViewMatrix;

float sqrt2pi = 2.506628275;
float epsilon = 0.0000001;


layout(r32i) uniform iimage2D img_startidx;
//layout(rgba32f) uniform image2D img_startidx;

layout(rgba32f) uniform image2D img_rendered;

layout(rgba32f) uniform image2D img_test;

GaussianRay GaussianParametersOnRay(int gaussIndex, vec3 origin, vec3 direction) {
	GaussianRay ray;
	Gaussian gauss = mixture.gaussians[gaussIndex];
	mat3 inv = mat3(gauss.invsigma);
	vec3 rs = direction*inv;
	float c2 = 1.0 / dot(rs, direction);
	float b = dot(rs, gauss.mu_alpha.xyz-origin) * c2;
	vec3 pivec = origin + b*direction - gauss.mu_alpha.xyz;
	float a = gauss.mu_alpha.w * exp(-0.5*dot(pivec*inv, pivec));
	ray.a = a;
	ray.b = b;
	ray.c2 = c2;
	ray.direction = vec4(direction, 1.0);
	return ray;
}

float evalGMM_classic(vec3 position, int gaussCount, int gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		Gaussian gauss = mixture.gaussians[gaussList[j]];
		vec3 relpos = position - gauss.mu_alpha.xyz;
		float ex = exp(-0.5 * dot(relpos*mat3(gauss.invsigma),relpos));
		sum += gauss.mu_alpha.w * ex;
	}
	return sum;
}

float evalGMM_classic_d(dvec3 position, int gaussCount, int gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		Gaussian gauss = mixture.gaussians[gaussList[j]];
		dvec3 relpos = position - gauss.mu_alpha.xyz;
		float ex = exp(float(-0.5 * dot(relpos*dmat3(gauss.invsigma),relpos)));
		sum += gauss.mu_alpha.w * ex;
	}
	return sum;
}

float evalGMM_ray(float z, int gaussCount, GaussianRay gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		GaussianRay gauss = gaussList[j];
		sum += gauss.a * exp(-0.5 * pow(z - gauss.b, 2)/gauss.c2);
	}
	return sum;
}

float evalGMM_ray_d(double z, int gaussCount, GaussianRay gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		GaussianRay gauss = gaussList[j];
		sum += gauss.a * exp(float(-0.5 * (z - gauss.b)*(z - gauss.b)/gauss.c2));
	}
	return sum;
}

float evalGMMderivative_ray(float z, int gaussCount, GaussianRay gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		GaussianRay gauss = gaussList[j];
		sum += -gauss.a * exp(-0.5 * pow(z - gauss.b, 2)/gauss.c2)*(z-gauss.b)/gauss.c2;
	}
	return sum;
}

float evalGMMderivative_ray_d(double z, int gaussCount, GaussianRay gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		GaussianRay gauss = gaussList[j];
		sum += -gauss.a * exp(float(-0.5 * (z - gauss.b)*(z - gauss.b)/gauss.c2)) * float((z-gauss.b)/gauss.c2);
	}
	return sum;
}

void evalGMM_valAndDerivative_ray_d(double z, int gaussCount, GaussianRay gaussList[FRAG_LIST_MAX_LEN / 2], out float val, out float derivative) {
	val = 0;
	derivative = 0;
	for (int j = 0; j < gaussCount; j++) {
		GaussianRay gauss = gaussList[j];
		float sampleval = gauss.a * exp(float(-0.5 * (z - gauss.b)*(z - gauss.b)/gauss.c2));
		val += sampleval;
		derivative += -float(sampleval*(z-gauss.b)/gauss.c2);
	}
}

double refine_newton(double z_n, double z_f, float val_f, int gaussCount, GaussianRay gaussList[FRAG_LIST_MAX_LEN / 2], out bool success, out bool failure) {
	double last_z = z_f;
	float last_val = val_f;
	float last_goal = abs(last_val - isolevel);
	float last_derivative = evalGMMderivative_ray_d(last_z, gaussCount, gaussList);
	int i = 0;
	do {
		if (i > 200) {
			success = false;
			failure = true;
			return 1000.0;
		}
		++i;
		double new_z = last_z - (last_val - isolevel)/last_derivative;
		float new_val, new_derivative;
		evalGMM_valAndDerivative_ray_d(new_z, gaussCount, gaussList, new_val, new_derivative);
		float new_goal = abs(new_val - isolevel);
		//if (new_goal > last_goal) {	//divergence
		if (new_z > z_f || new_z < z_n) {
			success = false;
			failure = false;
			return z_f;
		}
		last_z = new_z;
		last_val = new_val;
		last_goal = new_goal;
		last_derivative = new_derivative;
	} while (last_goal > epsilon);
	failure = false;
	return last_z;
}

double refine_regula_falsi(double z_n, double z_f, float val_f, int gaussCount, GaussianRay gaussList[FRAG_LIST_MAX_LEN / 2], out bool failure) {
	float val_n = evalGMM_ray_d(z_n, gaussCount, gaussList);
	double z_new;
	float val_new;
	int i = 0;
	failure = false;
	do {
		if (i > 200) {
			failure = true;
			return z_new;
		}
		z_new = (z_n*(val_f-isolevel) - z_f*(val_n-isolevel)) / (val_f - val_n);
		val_new = evalGMM_ray_d(z_new, gaussCount, gaussList);
		if (val_new < isolevel) {
			z_n = z_new;
			val_n = val_new;
		} else {
			z_f = z_new;
			val_f = val_new;
		}
	} while(abs(val_new - isolevel) > epsilon);
	return z_new;
}

void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 pixel_center = vec2(pixel_coords) + vec2(0.5);
	vec2 pixel_uv = pixel_center / vec2(width, height);
	vec2 d = pixel_uv * 2.0 - 1.0;
	float aspectRatio = float(width) / float(height);

	vec3 origin = vec3(0, 0, 0.0);
	vec3 direction = normalize(vec3(d.x * aspectRatio, d.y, -1/tan(fov/2.0)));
	vec4 p1 = vec4(origin, 1.0);
	vec4 p2 = vec4(origin + direction, 1.0);
	vec4 vp1 = invViewMatrix * p1;
	vec4 vp2 = invViewMatrix * p2;
	origin = vec3(vp1);
	direction = vec3(normalize(vp2.xyz - vp1.xyz));

	origin = vec3(origin.x, -origin.z, origin.y);
	direction = vec3(direction.x, -direction.z, direction.y);

	//ivec2 size = imageSize(img_startidx);
	//width und height sollten angegbene werden. size könnte größer sein
	if (pixel_coords.x < width && pixel_coords.y < height) {
//		int i = imageLoad(img_startidx, pixel_coords).r;
//		//float i = imageLoad(img_startidx, pixel_coords).r;
//		//imageStore(img_rendered, pixel_coords, vec4(i / 1000.0));
//		if (i > 0) {
//			//imageStore(img_rendered, pixel_coords, vec4(1));
//			imageStore(img_rendered, pixel_coords, vec4(float(i) / listSize));
//		} else {
//			imageStore(img_rendered, pixel_coords, vec4(0));
//		}

		double fragZ[FRAG_LIST_MAX_LEN];
		int fragGIdx[FRAG_LIST_MAX_LEN];
		int fragFlags[FRAG_LIST_MAX_LEN];
		vec4 fragPositions[FRAG_LIST_MAX_LEN];
		uint pos[FRAG_LIST_MAX_LEN];
		uint count = 0;

		int gaussList[FRAG_LIST_MAX_LEN / 2];
		int gaussCount = 0;
		GaussianRay gaussRayList[FRAG_LIST_MAX_LEN / 2];

		int node = imageLoad(img_startidx, pixel_coords).r;
		if (node == -1) {
			imageStore(img_rendered, pixel_coords, vec4(0));
			return;
		}
		while (node != -1 && count < FRAG_LIST_MAX_LEN) {
			fragFlags[count] = flb.fragmentList[node].flags;
			fragZ[count] = flb.fragmentList[node].z;
			fragPositions[count] = flb.fragmentList[node].position;
			if (fragFlags[count] == 1 && gaussCount < FRAG_LIST_MAX_LEN/2) {
				gaussList[gaussCount] = flb.fragmentList[node].gIndex;
				//vec3 rdir = normalize(fragPositions[count].xyz - origin);
				gaussRayList[gaussCount] = GaussianParametersOnRay(flb.fragmentList[node].gIndex, origin, direction);
				fragGIdx[count] = gaussCount;
				gaussCount++;
			}
			pos[count] = count;
			count++;
			node = flb.fragmentList[node].next;
		}
		if (count == FRAG_LIST_MAX_LEN) {
			imageStore(img_rendered, pixel_coords, vec4(1, 0, 0, 1));
			return;
		}
		for (uint i = 1; i < count; i++) {
			uint j = i;
			while (j > 0 && fragZ[pos[j-1]] > fragZ[pos[j]]) {
				uint temp = pos[j-1];
				pos[j-1] = pos[j];
				pos[j] = temp;
				j--;
			}
		}

		//imageStore(img_rendered, pixel_coords, vec4(fragZ[pos[0]] / 200.0));
		//return;

		//imageStore(img_rendered, pixel_coords, vec4(gaussCount / 64.0));
		//return;

//		CandidateList testList = createCandidateList();
//		insert(testList, 5.0);
//		insert(testList, 3.0, 6.0);
//		double z = popZ(testList);
//		z = popZ(testList);
//		z = popZ(testList);
//		z = popZ(testList);
//		z = popZ(testList);
//		//z = getNextZ(testList);
//
//		imageStore(img_rendered, pixel_coords, vec4(!hasNext(testList)));
//		return;


		CandidateList candidateList = createCandidateList();
		int input_next_index = 0;
		double zn = 0, zf = 0;
		//As long as there is another input or another candidate
		while (input_next_index < count || hasNext(candidateList)) {
			//Let's choose what to determine next
			//if there is only a candidate next, we go with that one
			//if there is only an input next, we go with that one
			//otherwise we have to choose the one with the lower z value
			bool process_input;
			if (hasNext(candidateList)) {
				if (input_next_index < count) {
					//Let's decide
					double zI = fragZ[pos[input_next_index]];
					double zC = getNextZ(candidateList);
					process_input = zI <= zC;
				} else {
					process_input = false;
				}
			} else {
				process_input = true;
			}

			//Input-Processing
			if (process_input) {
				//only choose front facing inputs (-> enable backface culling in fragment shader to simplify this)
				if (fragFlags[pos[input_next_index]] != 0) {
					GaussianRay ray = gaussRayList[fragGIdx[pos[input_next_index]]];
					if (ray.a > isolevel) {
						double tdist = sqrt(-2*ray.c2*log(isolevel/ray.a));
						double t1 = ray.b - tdist;
						//imageStore(img_rendered, pixel_coords, vec4(t1 / 200.0));
						//return;
						double t2 = ray.b + tdist;
						insert(candidateList, t1, t2);
					} else {
						//imageStore(img_rendered, pixel_coords, vec4(ray.b / 200.0));
						//return;
						insert(candidateList, ray.b);
					}
				}
				input_next_index++;
			}
			//Sample-Processing
			else {
				double z = popZ(candidateList);
				float val = evalGMM_ray_d(z, gaussCount, gaussRayList);

				if (abs(val - isolevel) <= epsilon) {
					//Shade and Render
					dvec3 pos = origin + z*direction;
					imageStore(img_rendered, pixel_coords, vec4(abs(pos/30.0), 1.0));
					return;
				} else if (val < isolevel) {
					zn = z;
					//imageStore(img_rendered, pixel_coords, vec4(0, 1, 0, 1));
					//return;
				} else if (val > isolevel) {
					zf = z;

					bool success = false;
					bool failure = false;
					//double znew = z;
					//double znew = refine_regula_falsi(zn, zf, val, gaussCount, gaussRayList);
					double znew = refine_newton(zn, zf, val, gaussCount, gaussRayList, success, failure);
//					//double znew = z;
					if (failure) {
						imageStore(img_rendered, pixel_coords, vec4(0.7, 0.7, 0.7, 1));
						return;
					}
					if (!success) {
						znew = refine_regula_falsi(zn, zf, val, gaussCount, gaussRayList, failure);
						if (failure) {
							imageStore(img_rendered, pixel_coords, vec4(0.5, 0.5, 0.5, 1));
							return;
						}
					}
//
//					//Shade and Render
					dvec3 pos = origin + z*direction;
					imageStore(img_rendered, pixel_coords, vec4(abs(pos/30.0), 1.0));
					//imageStore(img_rendered, pixel_coords, vec4(znew / 200.0));
//					//imageStore(img_rendered, pixel_coords, vec4(0, 1, 0, 1));
					return;
				}
			}
			
		}
		imageStore(img_rendered, pixel_coords, vec4(0));
		return;
	}
	//für den stencil test können wir keinen compute shader verwenden!
}