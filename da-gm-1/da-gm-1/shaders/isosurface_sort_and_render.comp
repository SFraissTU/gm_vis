#version 450

#define FRAG_LIST_MAX_LEN 128

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct FragmentData {
	int gIndex;
	int flags;
	int next;
	int padding1;
	double z;
	double padding2;
	//ivec4 g_f_n;
	vec4 position;
};

layout(std430, binding=0) buffer FragmentList {
	FragmentData[] fragmentList;
} flb;

struct Gaussian {
	vec4 mu_alpha;
	mat4 invsigma;
};

struct GaussianRay {
	float a;
	float b;
	float c2;
	float padding;
	vec4 direction;
};

layout(std430, binding=1) buffer GaussianMixture {
	Gaussian gaussians[];
} mixture;

struct LinkedListElement {
	double z;
	int next;
};

//Ordered Linked List
struct CandidateList {
	LinkedListElement candidates[FRAG_LIST_MAX_LEN];
	int candidates_len;
	int candidates_next_index;
};

CandidateList createCandidateList() {
	CandidateList list;
	list.candidates_len = 0;
	list.candidates_next_index = 0;
	return list;
};

void insert(inout CandidateList list, double t, int initialinspectionindex, int initialpreviousindex) {
	int inspectionindex = initialinspectionindex;
	int previousindex = initialpreviousindex;
	while (inspectionindex < list.candidates_len && inspectionindex != -1) {
		LinkedListElement candidate = list.candidates[inspectionindex];
		if (candidate.z > t) {
			LinkedListElement newC;
			newC.z = t;
			newC.next = inspectionindex;
			list.candidates[list.candidates_len] = newC;
			if (previousindex == -1) {
				list.candidates_next_index = list.candidates_len;
			} else {
				list.candidates[previousindex].next = list.candidates_len;
			}
			list.candidates_len++;
			break;
		}
		previousindex = inspectionindex;
		inspectionindex = candidate.next;
	}
	if (inspectionindex == -1 || inspectionindex == list.candidates_len) {
		//insert at beginning or end
		LinkedListElement newC;
		newC.z = t;
		newC.next = -1;
		list.candidates[list.candidates_len] = newC;
		if (previousindex != -1) {
			list.candidates[previousindex].next = list.candidates_len;
		}
		list.candidates_len++;
	}
};

void insert(inout CandidateList list, double t) {
	int inspectionindex = list.candidates_next_index;
	int previousindex = -1;
	insert(list, t, inspectionindex, previousindex);
}

void insert(inout CandidateList list, double t1, double t2) {
	//Insert t1
	insert(list, t1);
	//Insert t2
	insert(list, t2, list.candidates[list.candidates_len-1].next, list.candidates_len-1);
};


bool hasNext(CandidateList list) {
	return list.candidates_next_index < list.candidates_len;
};

double getNextZ(CandidateList list) {
	return list.candidates[list.candidates_next_index].z;
}

double popZ(inout CandidateList list) {
	double z = list.candidates[list.candidates_next_index].z;
	list.candidates_next_index = list.candidates[list.candidates_next_index].next;
	if (list.candidates_next_index == -1) {
		list.candidates_next_index = list.candidates_len;
	}
	return z;
}

uniform uint listSize;
uniform uint width;
uniform uint height;
uniform float isolevel;
uniform float fov;
uniform sampler1D gaussTex;
uniform mat4 invViewMatrix;

float sqrt2pi = 2.506628275;
float epsilon = 0.000000001;


layout(r32i) uniform iimage2D img_startidx;
//layout(rgba32f) uniform image2D img_startidx;

layout(rgba32f) uniform image2D img_rendered;

layout(rgba32f) uniform image2D img_test;

GaussianRay GaussianParametersOnRay(int gaussIndex, vec3 origin, vec3 direction) {
	GaussianRay ray;
	Gaussian gauss = mixture.gaussians[gaussIndex];
	mat3 inv = mat3(gauss.invsigma);
	vec3 rs = direction*inv;
	float c2 = 1.0 / dot(rs, direction);
	float b = dot(rs, gauss.mu_alpha.xyz-origin) * c2;
	vec3 pivec = origin + b*direction - gauss.mu_alpha.xyz;
	float a = gauss.mu_alpha.w * exp(-0.5*dot(pivec*inv, pivec));
	ray.a = a;
	ray.b = b;
	ray.c2 = c2;
	ray.direction = vec4(direction, 1.0);
	return ray;
}

float evalGMM_classic(vec3 position, int gaussCount, int gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		Gaussian gauss = mixture.gaussians[gaussList[j]];
		vec3 relpos = position - gauss.mu_alpha.xyz;
		float ex = exp(-0.5 * dot(relpos*mat3(gauss.invsigma),relpos));
		sum += gauss.mu_alpha.w * ex;
	}
	return sum;
}

float evalGMM_classic_d(dvec3 position, int gaussCount, int gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		Gaussian gauss = mixture.gaussians[gaussList[j]];
		dvec3 relpos = position - gauss.mu_alpha.xyz;
		float ex = exp(float(-0.5 * dot(relpos*dmat3(gauss.invsigma),relpos)));
		sum += gauss.mu_alpha.w * ex;
	}
	return sum;
}

float evalGMM_ray(float z, int gaussCount, GaussianRay gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		GaussianRay gauss = gaussList[j];
		sum += gauss.a * exp(-0.5 * pow(z - gauss.b, 2)/gauss.c2);
	}
	return sum;
}

float evalGMM_ray_d(double z, int gaussCount, GaussianRay gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		GaussianRay gauss = gaussList[j];
		sum += gauss.a * exp(float(-0.5 * (z - gauss.b)*(z - gauss.b)/gauss.c2));
	}
	return sum;
}

float evalGMMderivative_ray(float z, int gaussCount, GaussianRay gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		GaussianRay gauss = gaussList[j];
		sum += -gauss.a * exp(-0.5 * pow(z - gauss.b, 2)/gauss.c2)*(z-gauss.b)/gauss.c2;
	}
	return sum;
}

void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 pixel_center = vec2(pixel_coords) + vec2(0.5);
	vec2 pixel_uv = pixel_center / vec2(width, height);
	vec2 d = pixel_uv * 2.0 - 1.0;
	float aspectRatio = float(width) / float(height);

	vec3 origin = vec3(0, 0, 0.0);
	vec3 direction = normalize(vec3(d.x * aspectRatio, d.y, -1/tan(fov/2.0)));
	vec4 p1 = vec4(origin, 1.0);
	vec4 p2 = vec4(origin + direction, 1.0);
	vec4 vp1 = invViewMatrix * p1;
	vec4 vp2 = invViewMatrix * p2;
	origin = vec3(vp1);
	direction = vec3(normalize(vp2.xyz - vp1.xyz));

	origin = vec3(origin.x, -origin.z, origin.y);
	direction = vec3(direction.x, -direction.z, direction.y);

	//ivec2 size = imageSize(img_startidx);
	//width und height sollten angegbene werden. size könnte größer sein
	if (pixel_coords.x < width && pixel_coords.y < height) {
//		int i = imageLoad(img_startidx, pixel_coords).r;
//		//float i = imageLoad(img_startidx, pixel_coords).r;
//		//imageStore(img_rendered, pixel_coords, vec4(i / 1000.0));
//		if (i > 0) {
//			//imageStore(img_rendered, pixel_coords, vec4(1));
//			imageStore(img_rendered, pixel_coords, vec4(float(i) / listSize));
//		} else {
//			imageStore(img_rendered, pixel_coords, vec4(0));
//		}

		double fragZ[FRAG_LIST_MAX_LEN];
		int fragGIdx[FRAG_LIST_MAX_LEN];
		int fragFlags[FRAG_LIST_MAX_LEN];
		vec4 fragPositions[FRAG_LIST_MAX_LEN];
		uint pos[FRAG_LIST_MAX_LEN];
		uint count = 0;

		int gaussList[FRAG_LIST_MAX_LEN / 2];
		int gaussCount = 0;
		GaussianRay gaussRayList[FRAG_LIST_MAX_LEN / 2];

		int node = imageLoad(img_startidx, pixel_coords).r;
		if (node == -1) {
			imageStore(img_rendered, pixel_coords, vec4(0));
			return;
		}
		while (node != -1 && count < FRAG_LIST_MAX_LEN) {
			fragFlags[count] = flb.fragmentList[node].flags;
			fragZ[count] = flb.fragmentList[node].z;
			fragPositions[count] = flb.fragmentList[node].position;
			if (fragFlags[count] == 1 && gaussCount < FRAG_LIST_MAX_LEN/2) {
				gaussList[gaussCount] = flb.fragmentList[node].gIndex;
				//vec3 rdir = normalize(fragPositions[count].xyz - origin);
				gaussRayList[gaussCount] = GaussianParametersOnRay(flb.fragmentList[node].gIndex, origin, direction);
				fragGIdx[count] = gaussCount;
				gaussCount++;
			}
			pos[count] = count;
			count++;
			node = flb.fragmentList[node].next;
		}
		if (count == FRAG_LIST_MAX_LEN) {
			imageStore(img_rendered, pixel_coords, vec4(1, 0, 0, 1));
			return;
		}
		for (uint i = 1; i < count; i++) {
			uint j = i;
			while (j > 0 && fragZ[pos[j-1]] > fragZ[pos[j]]) {
				uint temp = pos[j-1];
				pos[j-1] = pos[j];
				pos[j] = temp;
				j--;
			}
		}

		//imageStore(img_rendered, pixel_coords, vec4(fragZ[pos[0]] / 200.0));
		//return;

		//imageStore(img_rendered, pixel_coords, vec4(gaussCount / 64.0));
		//return;

		CandidateList candidateList;
		int input_next_index = 0;
		double zn = 0, zf = 0;
		//for now: use all gaussians in this list
		//for (int i = 0; i < count; i++) {
		while (input_next_index < count || hasNext(candidateList)) {
			bool process_input = !hasNext(candidateList);
			if (!process_input) {
				if (input_next_index < 0) {
					//Let's decide
					double zI = fragZ[pos[input_next_index]];
					double zC = getNextZ(candidateList);
					process_input = zI <= zC;
				}
			}

			//Input-Processing
			if (process_input) {
				if (fragFlags[pos[input_next_index]] != 0) {
					GaussianRay ray = gaussRayList[pos[input_next_index]];
					if (ray.a > isolevel) {
						double tdist = sqrt(-2*ray.c2*log(isolevel/ray.a));
						double t1 = ray.b - tdist;
						double t2 = ray.b + tdist;
						insert(candidateList, t1, t2);
					} else {
						insert(candidateList, ray.b);
					}
					input_next_index++;
				}
			}
			//Sample-Processing
			else {
				double z = popZ(candidateList);
				float sum = evalGMM_ray_d(z, gaussCount, gaussRayList);

				if (abs(sum - isolevel) <= epsilon) {
					//Shade and Render
					imageStore(img_rendered, pixel_coords, vec4(0.2 + 1000*sum));
					return;
				} else if (sum < isolevel) {
					zn = z;
					//imageStore(img_rendered, pixel_coords, vec4(0, 1, 0, 1));
					//return;
				} else if (sum > isolevel) {
					zf = z;
					//Refine Solution
					//Shade and Render
					imageStore(img_rendered, pixel_coords, vec4(0.2 + 1000*sum));
					return;
				}
			}
			
		}
		imageStore(img_rendered, pixel_coords, vec4(0));
		return;
	}
	//für den stencil test können wir keinen compute shader verwenden!
}