#version 450

#define FRAG_LIST_MAX_LEN 128

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct FragmentData {
	int gIndex;
	int flags;
	int next;
	float z;
	//ivec4 g_f_n;
	vec4 position;
};

layout(std430, binding=0) buffer FragmentList {
	FragmentData[] fragmentList;
} flb;

struct Gaussian {
	vec4 mu_alpha;
	mat4 invsigma;
};

struct GaussianRay {
	float a;
	float b;
	float c2;
	float padding;
	vec4 direction;
};

layout(std430, binding=1) buffer GaussianMixture {
	Gaussian gaussians[];
} mixture;

uniform uint listSize;
uniform uint width;
uniform uint height;
uniform float isolevel;
uniform float fov;
uniform sampler1D gaussTex;
uniform mat4 invViewMatrix;

float sqrt2pi = 2.506628275;
float epsilon = 0.000000001;


layout(r32i) uniform iimage2D img_startidx;
//layout(rgba32f) uniform image2D img_startidx;

layout(rgba32f) uniform image2D img_rendered;

layout(rgba32f) uniform image2D img_test;

GaussianRay GaussianParametersOnRay(int gaussIndex, vec3 origin, vec3 direction) {
	GaussianRay ray;
	Gaussian gauss = mixture.gaussians[gaussIndex];
	mat3 inv = mat3(gauss.invsigma);
	vec3 rs = direction*inv;
	float c2 = 1.0 / dot(rs, direction);
	float b = dot(rs, gauss.mu_alpha.xyz-origin) * c2;
	vec3 pivec = origin + b*direction - gauss.mu_alpha.xyz;
	float a = gauss.mu_alpha.w * exp(-0.5*dot(pivec*inv, pivec));
	ray.a = a;
	ray.b = b;
	ray.c2 = c2;
	ray.direction = vec4(direction, 1.0);
	return ray;
}

float evalGMM_classic(vec3 position, int gaussCount, int gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		Gaussian gauss = mixture.gaussians[gaussList[j]];
		vec3 relpos = position - gauss.mu_alpha.xyz;
		float ex = exp(-0.5 * dot(relpos*mat3(gauss.invsigma),relpos));
		sum += gauss.mu_alpha.w * ex;
	}
	return sum;
}

float evalGMM_ray(float z, int gaussCount, GaussianRay gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		GaussianRay gauss = gaussList[j];
		sum += gauss.a * exp(-0.5 * pow(z - gauss.b, 2)/gauss.c2);
	}
	return sum;
}

float evalGMMderivative_ray(float z, int gaussCount, GaussianRay gaussList[FRAG_LIST_MAX_LEN / 2]) {
	float sum = 0;
	for (int j = 0; j < gaussCount; j++) {
		GaussianRay gauss = gaussList[j];
		sum += -gauss.a * exp(-0.5 * pow(z - gauss.b, 2)/gauss.c2)*(z-gauss.b)/gauss.c2;
	}
	return sum;
}

void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 pixel_center = vec2(pixel_coords) + vec2(0.5);
	vec2 pixel_uv = pixel_center / vec2(width, height);
	vec2 d = pixel_uv * 2.0 - 1.0;
	float aspectRatio = float(width) / float(height);

	vec3 origin = vec3(0, 0, 0.0);
	vec3 direction = normalize(vec3(d.x * aspectRatio, d.y, -1/tan(fov/2.0)));
	vec4 p1 = vec4(origin, 1.0);
	vec4 p2 = vec4(origin + direction, 1.0);
	vec4 vp1 = invViewMatrix * p1;
	vec4 vp2 = invViewMatrix * p2;
	origin = vec3(vp1);
	direction = vec3(normalize(vp2 - vp1));

	origin = vec3(origin.x, -origin.z, origin.y);
	direction = vec3(direction.x, -direction.z, direction.y);

	//ivec2 size = imageSize(img_startidx);
	//width und height sollten angegbene werden. size könnte größer sein
	if (pixel_coords.x < width && pixel_coords.y < height) {
//		int i = imageLoad(img_startidx, pixel_coords).r;
//		//float i = imageLoad(img_startidx, pixel_coords).r;
//		//imageStore(img_rendered, pixel_coords, vec4(i / 1000.0));
//		if (i > 0) {
//			//imageStore(img_rendered, pixel_coords, vec4(1));
//			imageStore(img_rendered, pixel_coords, vec4(float(i) / listSize));
//		} else {
//			imageStore(img_rendered, pixel_coords, vec4(0));
//		}

		float fragZ[FRAG_LIST_MAX_LEN];
		int fragGIdx[FRAG_LIST_MAX_LEN];
		int fragFlags[FRAG_LIST_MAX_LEN];
		vec4 fragPositions[FRAG_LIST_MAX_LEN];
		uint pos[FRAG_LIST_MAX_LEN];
		uint count = 0;

		int gaussList[FRAG_LIST_MAX_LEN / 2];
		int gaussCount = 0;
		GaussianRay gaussRayList[FRAG_LIST_MAX_LEN / 2];

		int node = imageLoad(img_startidx, pixel_coords).r;
		if (node == -1) {
			imageStore(img_rendered, pixel_coords, vec4(0));
			return;
		}
		while (node != -1 && count < FRAG_LIST_MAX_LEN) {
			fragGIdx[count] = flb.fragmentList[node].gIndex;
			fragFlags[count] = flb.fragmentList[node].flags;
			fragZ[count] = flb.fragmentList[node].z;
			fragPositions[count] = flb.fragmentList[node].position;
			if (fragFlags[count] == 1 && gaussCount < FRAG_LIST_MAX_LEN/2) {
				gaussList[gaussCount] = fragGIdx[count];
				vec3 rdir = normalize(fragPositions[count].xyz - origin);
				gaussRayList[gaussCount] = GaussianParametersOnRay(fragGIdx[count], origin, rdir);
				gaussCount++;
			}
			pos[count] = count;
			count++;
			node = flb.fragmentList[node].next;
		}
		if (count == FRAG_LIST_MAX_LEN) {
			imageStore(img_rendered, pixel_coords, vec4(1, 0, 0, 1));
			return;
		}
		for (uint i = 1; i < count; i++) {
			uint j = i;
			while (j > 0 && fragZ[pos[j-1]] > fragZ[pos[j]]) {
				uint temp = pos[j-1];
				pos[j-1] = pos[j];
				pos[j] = temp;
				j--;
			}
		}

		//imageStore(img_rendered, pixel_coords, vec4(fragZ[pos[0]] / 200.0));
		//return;

		//imageStore(img_rendered, pixel_coords, vec4(gaussCount / 64.0));
		//return;

		float zn = 0, zf = 0;
		imageStore(img_rendered, pixel_coords, vec4(0));
		//for now: use all gaussians in this list
		for (int i = 0; i < count; i++) {
			vec3 position = fragPositions[pos[i]].xyz;
			//float z = distance(origin, pos);

			vec3 sum = vec3(0);
			for (int j = 0; j < gaussCount; j++) {
				GaussianRay gauss = gaussRayList[j];
				sum += gauss.direction.xyz;
			}
			//vec3 rdir = normalize(fragPositions[pos[i]].xyz - origin);
			//sum += rdir;
			sum /= gaussCount;
			vec3 std = vec3(0);
			for (int j = 0; j < gaussCount; j++) {
				GaussianRay gauss = gaussRayList[j];
				std += abs(gauss.direction.xyz-sum);
			}
			std /= gaussCount;
			if (pixel_coords.x < width - pixel_coords.y) {
				imageStore(img_rendered, pixel_coords, vec4(abs(std), 1.0));
			}
			else {
				imageStore(img_rendered, pixel_coords, vec4(abs(sum), 1.0));
			}

			//if (pixel_coords.x < width/2) {
				//float sum = evalGMM_classic(pos, gaussCount, gaussList);
				//float sum = evalGMM_ray(z, gaussCount, gaussRayList);
				//imageStore(img_rendered, pixel_coords, vec4(0.2 + sum*1000000));
				//imageStore(img_rendered, pixel_coords, vec4(sum));
			//} else {
				//imageStore(img_rendered, pixel_coords, vec4((ivec3(pos)%25) / 25.0, 1.0));
			//}
			return;

			//float z = fragZ[pos[i]];
			
			

			//imageStore(img_rendered, pixel_coords, vec4(z / 200.0));
			
			//imageStore(img_rendered, pixel_coords, fragPositions[pos[i]]);
			//imageStore(img_rendered, pixel_coords, vec4(fragGIdx[pos[i]] / 500.0));
			//return;
			//float sum = sum2;
			//sum = mixture.gaussians[fragGIdx[pos[i]]].mu_alpha.w;
			//imageStore(img_rendered, pixel_coords, vec4((ivec3(origin + z*direction).zzz % 10) / 10.0, 1));
			//imageStore(img_rendered, pixel_coords, vec4(z / 60.0));
//			if (pixel_coords.x < width/2) {
////				float val = fragGIdx[pos[i]] / 10.0;
////				//float val = z;
////				val = (int(val) % 10) / 10.0;
////				imageStore(img_rendered, pixel_coords, vec4(val));
//				imageStore(img_rendered, pixel_coords, imageLoad(img_test, pixel_coords));
//			} else {
//				vec4 position = fragPositions[pos[i]];
//				//vec3 position = origin + z*direction;
//				//float val = length(position - origin);
//				float val = abs(position).z / 0.6;
//				//float val = z;
//				val = (int(val) % 10) / 10.0;
//				imageStore(img_rendered, pixel_coords, vec4(val));
//				return;
			//}
			//return;
			//return;
			//imageStore(img_rendered, pixel_coords, vec4(sum*100000));
			//return;
//			if (abs(sum - isolevel) <= epsilon) {
//				//Shade and Render
//				imageStore(img_rendered, pixel_coords, vec4(z / 200.0));
//				return;
//			} else if (sum < isolevel) {
//				zn = z;
//				//imageStore(img_rendered, pixel_coords, vec4(0, 1, 0, 1));
//				//return;
//			} else if (sum > isolevel) {
//				zf = z;
//				//Refine Solution
//				//Shade and Render
//				imageStore(img_rendered, pixel_coords, vec4(z / 200.0));
//				return;
//			}
		}
		return;
		imageStore(img_rendered, pixel_coords, vec4(0));
		return;
	}
	//für den stencil test können wir keinen compute shader verwenden!
}