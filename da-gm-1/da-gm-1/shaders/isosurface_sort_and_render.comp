#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

struct FragmentData {
	float z;
	int gIndex;
	int flags;
	int next;
};

layout(std430, binding=0) buffer FragmentList {
	FragmentData[] fragmentList;
} flb;

struct Gaussian {
	vec4 mu_alpha;
	mat4 invsigma;
};

layout(std430, binding=1) buffer GaussianMixture {
	Gaussian gaussians[];
} mixture;

uniform uint listSize;
uniform uint width;
uniform uint height;
uniform float isolevel;
uniform float fov;
uniform sampler1D gaussTex;
uniform mat4 invViewMatrix;

float sqrt2pi = 2.506628275;
float epsilon = 0.000000001;


layout(r32i) uniform iimage2D img_startidx;
//layout(rgba32f) uniform image2D img_startidx;

layout(rgba32f) uniform image2D img_rendered;

//float refine(float zn, float zf) {

//}

void main() {
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	vec2 pixel_center = vec2(pixel_coords) + vec2(0.5);
	vec2 pixel_uv = pixel_center / vec2(width, height);
	vec2 d = pixel_uv * 2.0 - 1.0;
	float aspectRatio = float(width) / float(height);

	vec3 origin = vec3(0, 0, 0.0);
	vec3 direction = normalize(vec3(d.x * aspectRatio, d.y, -1/tan(fov/2.0)));
	vec4 p1 = vec4(origin, 1.0);
	vec4 p2 = vec4(origin + direction, 1.0);
	vec4 vp1 = invViewMatrix * p1;
	vec4 vp2 = invViewMatrix * p2;
	origin = vec3(vp1);
	direction = vec3(normalize(vp2 - vp1));

	origin = vec3(origin.x, -origin.z, origin.y);
	direction = vec3(direction.x, -direction.z, direction.y);

	//ivec2 size = imageSize(img_startidx);
	//width und height sollten angegbene werden. size könnte größer sein
	if (pixel_coords.x < width && pixel_coords.y < height) {
//		int i = imageLoad(img_startidx, pixel_coords).r;
//		//float i = imageLoad(img_startidx, pixel_coords).r;
//		//imageStore(img_rendered, pixel_coords, vec4(i / 1000.0));
//		if (i > 0) {
//			//imageStore(img_rendered, pixel_coords, vec4(1));
//			imageStore(img_rendered, pixel_coords, vec4(float(i) / listSize));
//		} else {
//			imageStore(img_rendered, pixel_coords, vec4(0));
//		}

		float fragZ[128];
		int fragGIdx[128];
		int fragFlags[128];
		uint pos[128];
		uint count = 0;

		int gaussList[64];
		int gaussCount = 0;

		int node = imageLoad(img_startidx, pixel_coords).r;
		if (node == -1) {
			imageStore(img_rendered, pixel_coords, vec4(0));
			return;
		}
		while (node != -1 && count < 128) {
			fragZ[count] = flb.fragmentList[node].z;
			fragGIdx[count] = flb.fragmentList[node].gIndex;
			fragFlags[count] = flb.fragmentList[node].flags;
			if (fragFlags[count] == 1 && gaussCount < 64) {
				gaussList[gaussCount] = fragGIdx[count];
				gaussCount++;
			}
			pos[count] = count;
			count++;
			node = flb.fragmentList[node].next;
		}
		if (count == 128) {
			imageStore(img_rendered, pixel_coords, vec4(1, 0, 0, 1));
			return;
		}
		for (uint i = 1; i < count; i++) {
			uint j = i;
			while (j > 0 && fragZ[pos[j-1]] > fragZ[pos[j]]) {
				uint temp = pos[j-1];
				pos[j-1] = pos[j];
				pos[j] = temp;
				j--;
			}
		}

		//imageStore(img_rendered, pixel_coords, vec4(fragZ[pos[0]] / 200.0));
		//return;

		//imageStore(img_rendered, pixel_coords, vec4(gaussCount / 64.0));
		//return;

		float zn = 0, zf = 0;
		//for now: use all gaussians in this list
		for (int i = 0; i < count; i++) {
			float z = fragZ[pos[i]];
			//float sum = 0;
			vec3 sum = vec3(0);
			for (int j = 0; j < gaussCount; j++) {
				//Gaussian gauss = mixture.gaussians[gaussList[j]];
				Gaussian gauss = mixture.gaussians[fragGIdx[pos[i]]];
				vec3 relpos = origin + z*direction - gauss.mu_alpha.xyz;
				float ex = exp(-0.5 * dot(relpos*mat3(gauss.invsigma),relpos));
				//sum += gauss.mu_alpha.w * ex;
				//sum += 1.0 / dot(relpos*mat3(gauss.invsigma),relpos);
				sum += (origin + z*direction).xyz;
				//sum += length(origin + z*direction);
				break;

//				mat3 inv = mat3(gauss.invsigma);
//				vec3 rs = direction*inv;
//				float sig2 = 1.0 / dot(rs, direction);
//				float mu = dot(rs, gauss.mu_alpha.xyz-origin) * sig2;
//				float sig = sqrt(sig2);
//				vec3 pivec = origin + mu*direction - gauss.mu_alpha.xyz;
//				float gammak = sqrt2pi * gauss.mu_alpha.w * sig * exp(-0.5*dot(pivec*inv, pivec));
//				sum += gammak * texture(gaussTex, mu / sig).r;
			}
			//sum = mixture.gaussians[fragGIdx[pos[i]]].mu_alpha.w;
			//imageStore(img_rendered, pixel_coords, vec4(z / 200.0));
			//return;
			imageStore(img_rendered, pixel_coords, vec4(sum / 60, 1));
			return;
//			if (abs(sum - isolevel) <= epsilon) {
//				//Shade and Render
//				imageStore(img_rendered, pixel_coords, vec4(z / 200.0));
//				return;
//			} else if (sum < isolevel) {
//				zn = z;
//				//imageStore(img_rendered, pixel_coords, vec4(0, 1, 0, 1));
//				//return;
//			} else if (sum > isolevel) {
//				zf = z;
//				//Refine Solution
//				//Shade and Render
//				imageStore(img_rendered, pixel_coords, vec4(z / 200.0));
//				return;
//			}
		}
		imageStore(img_rendered, pixel_coords, vec4(0));
		return;
	}
	//für den stencil test können wir keinen compute shader verwenden!
}